// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity =0.8.13;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/** 
@title  An ERC20 with rebase capabilities. Anyone can sacrifice tokens to rebase up the balance
        of all addresses that are currently rebasing.
@author eswak
@notice This contract is meant to be used to distribute rewards proportionately to all holders of
        a token, for instance to distribute buybacks or income generated by a protocol.

        Anyone can subscribe to rebasing by calling `enterRebase()`, and unsubcribe with `exitRebase()`.
        Anyone can burn tokens they own to `distribute(uint256)` proportionately to rebasing addresses.

        The following conditions are always met :
        ```
        totalSupply() == nonRebasingSupply() + rebasingSupply()
        sum of balanceOf(x) == totalSupply() [+= rounding down errors of 1 wei for each balanceOf]
        ```
*/
abstract contract ERC20RebaseDistributor is ERC20 {

    /*///////////////////////////////////////////////////////////////
                            EVENTS
    ///////////////////////////////////////////////////////////////*/

    /// @notice Emitted when an `account` enters rebasing.
    event RebaseEnter(address indexed account, uint256 indexed timestamp, uint256 accountBalance);
    /// @notice Emitted when an `account` exits rebasing.
    event RebaseExit(address indexed account, uint256 indexed timestamp, uint256 accountBalance);
    /// @notice Emitted when an `amount` of tokens is distributed by `source` to the rebasing accounts.
    event RebaseDistribution(address indexed source, uint256 indexed timestamp, uint256 amount);

    /*///////////////////////////////////////////////////////////////
                            INTERNAL STATE
    ///////////////////////////////////////////////////////////////*/

    struct RebasingState {
        uint8 isRebasing;
        uint248 nShares;
    }

    /// @notice For internal accounting. Number of rebasing shares for each rebasing accounts. 0 if account is not rebasing.
    mapping(address=>RebasingState) internal rebasingState;

    /// @notice For internal accounting. Total number of rebasing shares
    uint256 internal totalRebasingShares;

    /// @notice For internal accounting. Number of tokens per share for the rebasing supply. Starts at 1e18 and goes up only.
    uint256 internal rebasingSharePrice = 1e18;

    /// @notice For internal accounting. Number of tokens distributed to rebasing addresses that have not
    /// yet been materialized by a movement in the rebasing addresses.
    uint256 internal pendingRebaseRewards;

    /*///////////////////////////////////////////////////////////////
                            EXTERNAL API
    ///////////////////////////////////////////////////////////////*/

    /// @notice Enter rebasing supply. All subsequent distributions will increase the balance
    /// of `msg.sender` proportionately.
    function enterRebase() external {
        require(rebasingState[msg.sender].isRebasing == 0, "ERC20RebaseDistributor: already rebasing");
        _enterRebase(msg.sender);
    }
    function _enterRebase(address account) internal {
        uint256 balance = balanceOf(account);
        uint256 shares = balance * 1e18 / rebasingSharePrice;
        rebasingState[account].nShares = uint248(shares);
        rebasingState[account].isRebasing = 1;
        totalRebasingShares += shares;
        emit RebaseEnter(account, block.timestamp, balance);
    }

    /// @notice Exit rebasing supply. All pending rebasing rewards are physically minted to the user,
    /// and they won't be affected by rebases anymore.
    function exitRebase() external {
        require(rebasingState[msg.sender].isRebasing == 1, "ERC20RebaseDistributor: not rebasing");
        _exitRebase(msg.sender);
    }
    function _exitRebase(address account) internal {
        uint256 rawBalance = ERC20.balanceOf(account);
        uint256 shares = uint256(rebasingState[account].nShares);
        uint256 rebasedBalance = shares * rebasingSharePrice / 1e18;
        uint256 mintAmount = rebasedBalance - rawBalance;
        if (mintAmount != 0) {
            ERC20._mint(account, mintAmount);
            pendingRebaseRewards -= mintAmount;
        }

        rebasingState[account].nShares = 0;
        rebasingState[account].isRebasing = 0;
        totalRebasingShares -= shares;

        emit RebaseExit(account, block.timestamp, rebasedBalance);
    }

    /// @notice distribute tokens proportionately to all rebasing accounts.
    function distribute(uint256 amount) external {
        uint256 _totalRebasingShares = totalRebasingShares;
        require(_totalRebasingShares != 0, "ERC20RebaseDistributor: no rebase recipients");

        // burn the tokens received
        _burn(msg.sender, amount);

        // adjust up the balance of all accounts that are rebasing by increasing
        // the share price of rebasing tokens
        uint256 _rebasingSharePrice = rebasingSharePrice;
        uint256 _rebasingSupply = _totalRebasingShares * _rebasingSharePrice / 1e18;
        rebasingSharePrice = _rebasingSharePrice * (_rebasingSupply + amount) / _rebasingSupply;
        pendingRebaseRewards += amount;

        emit RebaseDistribution(msg.sender, block.timestamp, amount);
    }

    /// @notice True if an address subscribed to rebasing.
    function isRebasing(address account) public view returns (bool) {
        return rebasingState[account].isRebasing == 1;
    }

    /// @notice Total number of the tokens that are rebasing.
    function rebasingSupply() public view returns (uint256) {
        return totalRebasingShares * rebasingSharePrice / 1e18;
    }
    
    /// @notice Total number of the tokens that are not rebasing.
    function nonRebasingSupply() external view virtual returns (uint256) {
        return totalSupply() - rebasingSupply();
    }

    /*///////////////////////////////////////////////////////////////
                            ERC20 OVERRIDE
    ///////////////////////////////////////////////////////////////*/

    /// @notice Override of balanceOf() that takes into account the pending undistributed rebase rewards.
    function balanceOf(address account) public view virtual override returns (uint256) {
        uint256 _rebasingShares = rebasingState[account].nShares;
        if (_rebasingShares == 0) {
            return ERC20.balanceOf(account);
        } else {
            return _rebasingShares * rebasingSharePrice / 1e18;
        }
    }

    /// @notice Total number of the tokens in existence.
    function totalSupply() public view virtual override returns (uint256) {
        return ERC20.totalSupply() + pendingRebaseRewards;
    }

    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
    /// and re-enter rebasing after movement (if rebasing).
    function _burn(address account, uint256 amount) internal virtual override {
        bool isRebasingAccount = isRebasing(account);
        if (isRebasingAccount) {
            _exitRebase(account);
        }
        ERC20._burn(account, amount);
        if (isRebasingAccount) {
            _enterRebase(account);
        }
    }

    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
    /// and re-enter rebasing after movement (if rebasing).
    function _mint(address account, uint256 amount) internal virtual override {
        bool isRebasingAccount = isRebasing(account);
        if (isRebasingAccount) {
            _exitRebase(account);
        }
        ERC20._mint(account, amount);
        if (isRebasingAccount) {
            _enterRebase(account);
        }
    }

    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
    /// and re-enter rebasing after movement (if rebasing).
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        bool isRebasingFrom = isRebasing(msg.sender);
        bool isRebasingTo = isRebasing(to);
        if (isRebasingFrom) {
            _exitRebase(msg.sender);
        }
        if (isRebasingTo) {
            _exitRebase(to);
        }
        bool success = ERC20.transfer(to, amount);
        if (isRebasingFrom) {
            _enterRebase(msg.sender);
        }
        if (isRebasingTo) {
            _enterRebase(to);
        }
        return success;
    }

    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
    /// and re-enter rebasing after movement (if rebasing).
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        bool isRebasingFrom = isRebasing(from);
        bool isRebasingTo = isRebasing(to);
        if (isRebasingFrom) {
            _exitRebase(from);
        }
        if (isRebasingTo) {
            _exitRebase(to);
        }
        bool success = ERC20.transferFrom(from, to, amount);
        if (isRebasingFrom) {
            _enterRebase(from);
        }
        if (isRebasingTo) {
            _enterRebase(to);
        }
        return success;
    }
}
