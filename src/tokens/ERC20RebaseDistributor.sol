// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity =0.8.13;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/** 
@title  An ERC20 with rebase capabilities. Anyone can sacrifice tokens to rebase up the balance
        of all addresses that are currently rebasing.
@author eswak
@notice This contract is meant to be used to distribute rewards proportionately to all holders of
        a token, for instance to distribute buybacks or income generated by a protocol.

        Anyone can subscribe to rebasing by calling enterRebase(), and unsubcribe with exitRebase().
        Anyone can burn tokens they own to distribute proportionately to 

        The following conditions are always met :
        totalSupply() == nonRebasingSupply() + rebasingSupply() + rebasingSupplyPendingProfits()
        sum of balanceOf(x) == totalSupply() (+= rounding errors of 1 wei)
        rebasingSupply() + rebasingSupplyPendingProfits() == totalRebasingShares() * rebasingSharePrice() / 1e18 (+= rounding errors of 1 wei)
        sum of rebasingShares(x) == totalRebasingShares() (+= rounding errors of 1 wei)
*/
abstract contract ERC20RebaseDistributor is ERC20 {

    /*///////////////////////////////////////////////////////////////
                            EVENTS
    ///////////////////////////////////////////////////////////////*/

    /// @notice Emitted when an `account` enters rebasing.
    event RebaseEnter(address indexed account, uint256 indexed timestamp, uint256 accountBalance);
    /// @notice Emitted when an `account` exits rebasing.
    event RebaseExit(address indexed account, uint256 indexed timestamp, uint256 accountBalance);
    /// @notice Emitted when an `amount` of tokens is distributed by `source` to the rebasing accounts.
    event RebaseDistribution(address indexed source, uint256 indexed timestamp, uint256 amount);

    /*///////////////////////////////////////////////////////////////
                            PUBLIC STATE
    ///////////////////////////////////////////////////////////////*/

    /// @notice mapping of addresses that are rebasing.
    mapping(address=>bool) public isRebasing;

    /// @notice Total number of tokens that are currently rebased by the distributions.
    uint256 public rebasingSupply;

    /*///////////////////////////////////////////////////////////////
                            INTERNAL STATE
    ///////////////////////////////////////////////////////////////*/

    /// @notice For internal accounting. Number of rebasing shares for each rebasing accounts. 0 if account is not rebasing.
    mapping(address=>uint256) internal rebasingShares;

    /// @notice For internal accounting. Total number of rebasing shares
    uint256 internal totalRebasingShares;

    /// @notice For internal accounting. Number of tokens per share for the rebasing supply. Starts at 1e18 and goes up only.
    uint256 internal rebasingSharePrice = 1e18;

    /*///////////////////////////////////////////////////////////////
                            EXTERNAL API
    ///////////////////////////////////////////////////////////////*/

    /// @notice Enter rebasing supply. All subsequent distributions will increase the balance
    /// of `msg.sender` proportionately.
    function enterRebase() external {
        require(!isRebasing[msg.sender], "ERC20RebaseDistributor: already rebasing");
        _enterRebase(msg.sender);
    }
    function _enterRebase(address account) internal {
        uint256 balance = balanceOf(account);
        uint256 _rebasingSupply = rebasingSupply;
        uint256 shares = balance * 1e18 / rebasingSharePrice;
        rebasingShares[account] = shares;
        totalRebasingShares += shares;
        rebasingSupply = _rebasingSupply + balance;
        isRebasing[account] = true;
        emit RebaseEnter(account, block.timestamp, balance);
    }

    /// @notice Exit rebasing supply. All pending rebasing rewards are physically minted to the user,
    /// and they won't be affected by rebases anymore.
    function exitRebase() external {
        require(isRebasing[msg.sender], "ERC20RebaseDistributor: not rebasing");
        _exitRebase(msg.sender);
    }
    function _exitRebase(address account) internal {
        uint256 rawBalance = ERC20.balanceOf(account);
        uint256 shares = rebasingShares[account];
        uint256 rebasedBalance = shares * rebasingSharePrice / 1e18;
        uint256 mintAmount = rebasedBalance - rawBalance;
        if (mintAmount != 0) {
            ERC20._mint(account, mintAmount);
        }

        rebasingSupply -= rawBalance;
        rebasingShares[account] = 0;
        totalRebasingShares -= shares;
        isRebasing[account] = false;

        emit RebaseExit(account, block.timestamp, rawBalance);
    }

    /// @notice distribute tokens proportionately to all rebasing accounts.
    function distribute(uint256 amount) external {
        uint256 _totalRebasingShares = totalRebasingShares;
        require(_totalRebasingShares != 0, "ERC20RebaseDistributor: no rebase recipients");

        // burn the tokens received
        _burn(msg.sender, amount);

        // adjust up the balance of all accounts that are rebasing by increasing
        // the share price of rebasing tokens
        uint256 _rebasingSharePrice = rebasingSharePrice;
        uint256 _rebasingSupplyValue = _totalRebasingShares * _rebasingSharePrice / 1e18;
        rebasingSharePrice = _rebasingSharePrice * (_rebasingSupplyValue + amount) / _rebasingSupplyValue;

        emit RebaseDistribution(msg.sender, block.timestamp, amount);
    }

    /// @notice Total pending rewards (unrealized profits) from the currently rebasing token supply.
    function rebasingSupplyPendingProfits() public view returns (uint256) {
        return totalRebasingShares * rebasingSharePrice / 1e18 - rebasingSupply;
    }
    
    /// @notice Number of the tokens that are not rebasing.
    function nonRebasingSupply() external view virtual returns (uint256) {
        return ERC20.totalSupply() - rebasingSupply;
    }

    /*///////////////////////////////////////////////////////////////
                            ERC20 OVERRIDE
    ///////////////////////////////////////////////////////////////*/

    /// @notice Override of balanceOf() that takes into account the pending undistributed rebase rewards.
    function balanceOf(address account) public view virtual override returns (uint256) {
        uint256 rawBalance = ERC20.balanceOf(account);
        uint256 _rebasingShares = rebasingShares[account];
        if (_rebasingShares == 0) {
            return rawBalance;
        } else {
            return _rebasingShares * rebasingSharePrice / 1e18;
        }
    }

    /// @notice Override of totalSupply() that takes into account the pending undistributed rebase rewards.
    function totalSupply() public view virtual override returns (uint256) {
        return ERC20.totalSupply() + rebasingSupplyPendingProfits();
    }

    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
    /// and re-enter rebasing after movement (if rebasing).
    function _burn(address account, uint256 amount) internal virtual override {
        bool isRebasingAccount = isRebasing[account];
        if (isRebasingAccount) {
            _exitRebase(account);
        }
        ERC20._burn(account, amount);
        if (isRebasingAccount) {
            _enterRebase(account);
        }
    }

    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
    /// and re-enter rebasing after movement (if rebasing).
    function _mint(address account, uint256 amount) internal virtual override {
        bool isRebasingAccount = isRebasing[account];
        if (isRebasingAccount) {
            _exitRebase(account);
        }
        ERC20._mint(account, amount);
        if (isRebasingAccount) {
            _enterRebase(account);
        }
    }

    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
    /// and re-enter rebasing after movement (if rebasing).
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        bool isRebasingFrom = isRebasing[msg.sender];
        bool isRebasingTo = isRebasing[to];
        if (isRebasingFrom) {
            _exitRebase(msg.sender);
        }
        if (isRebasingTo) {
            _exitRebase(to);
        }
        bool success = ERC20.transfer(to, amount);
        if (isRebasingFrom) {
            _enterRebase(msg.sender);
        }
        if (isRebasingTo) {
            _enterRebase(to);
        }
        return success;
    }

    /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
    /// and re-enter rebasing after movement (if rebasing).
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        bool isRebasingFrom = isRebasing[from];
        bool isRebasingTo = isRebasing[to];
        if (isRebasingFrom) {
            _exitRebase(from);
        }
        if (isRebasingTo) {
            _exitRebase(to);
        }
        bool success = ERC20.transferFrom(from, to, amount);
        if (isRebasingFrom) {
            _enterRebase(from);
        }
        if (isRebasingTo) {
            _enterRebase(to);
        }
        return success;
    }
}
